geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~ cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(class ~ cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(~mpg)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~year)
View(mpg)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~cty)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(. ~cty)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~cty)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(. ~ cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(~ cyl .)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(drv ~ .)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(~ cyl .)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(. ~ cyl)
library(swirl)
library("swirl")
install.packages("swirl")
library(swirl)
swirl()
swirl()
swirl()
plot(child~parent, galton)
plot(jitter(child, 4) ~ parent, galton)
lm(child ~ parent, galton)
regrline <- lm(child ~ parent, galton)
abline(regrline, lwd=3, col='red')
summary(regrline)
install_course("Getting and Cleaning Data")
swirl()
0
quit()
getOption(libpath)
getOption("libpath")
getOption("libPath")
fnc <- function () { y = 10 }
y=5
fnc <- function () { y = 10 }
fnc <- function () { y = 10 return(y)}
fnc <- function () { y = 10; return(y)}
y
fnc()
y
fnc <- function () { y <- 10; return(y)}
y
y <-  5
fnc <- function () {return(y)}
fnc
install.packages(dplyr)
y <- 10
f <- function(x) { y <- 3; 2*y + g(x)}
g <- function(x) {3*x}
f(3)
g <- function(x) {x*y}
f(3)
f <- function(x) { y <- 2; 2*y + g(x)}
f(3)
install.packages("memisc")
install.packages(dplyr)
install.packages("dplyr")
install.packages(c("acs", "curl", "dplyr", "git2r", "igraph", "modelr"))
# Chunk 1
knitr::opts_chunk$set(echo = F,
warning = F,
message = F,
fig.width = 7,
fig.align = "center",
out.width = "80%",
fig.height = 6)
# Chunk 2: loading libraries and data
library(tidyverse)
library(gridExtra)
library(choroplethr)
library(data.table)
library(GGally)
library(car)
setwd("c:/users/christopher/desktop/nanodegree/p4-eda/eda project")
variables = c("ProsperScore",
"ProsperRating..Alpha.",
"BorrowerAPR",
"BorrowerRate",
"LenderYield",
"IsBorrowerHomeowner",
"IncomeRange",
"StatedMonthlyIncome",
"DebtToIncomeRatio",
"MonthlyLoanPayment",
"LoanOriginalAmount",
"AmountDelinquent",
"BorrowerState",
"LoanStatus",
"CreditScoreRangeUpper",
"CreditScoreRangeLower")
loans <- read.csv("prosperLoanData.csv", na.strings=c("",".","NA"))[variables]
loans$AverageCredit <- round((loans$CreditScoreRangeUpper +
loans$CreditScoreRangeLower)/2)
loans <- loans[-15:-16]
attach(loans)
# Chunk 3: Data Structure
str(loans)
summary(loans)
# Chunk 4
#we make a data.table for easy joining with the state data set
state_totals <- data.table(group_by(loans, BorrowerState) %>%
dplyr::summarize(n()))
state_totals <- state_totals[!is.na(state_totals$BorrowerState),]
#removing the NA row
state_totals <- state_totals[-8,]
#removing DC, which is too difficult to convert
names(state_totals)[1:2] <- c("state.abb","value")
# joining a state name column on a common name for the abb column
state_totals <- inner_join(state_totals, data.table(state.name, state.abb))
names(state_totals)[3] <- c("region")
state_totals$region <- tolower(state_totals$region)
#Make the map
state_choropleth(state_totals,
title = "Number of Loans per State (Borrower-Reported)",
legend = "Number of Loans", num_colors = 1)
#because the chloroplethr package masks dplyr, we unload it
unloadNamespace(choroplethr)
# Chunk 5
par(las=2, mar = c(8, 4, 2, 2), cex.axis = 0.8)
boxplot(LoanOriginalAmount ~ BorrowerState, loans, range=0, ylab =
"Loan Original Amounts")
#Code adapted from an example in Roger Peng's "The Art of Data Science", pg. 48.
# Chunk 6
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
data.frame(round(na_count/nrow(loans), 4))
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
# Chunk 7
ggplot(data = loans, aes(x=MonthlyLoanPayment)) +
geom_histogram(binwidth = 25) + xlim(0, 1500)
# Chunk 8: PropserScores Hist
q1 <- qplot(data=loans, x=ProsperScore, geom = "bar")
q2 <- qplot(data=subset(loans, !is.na(ProsperRating..Alpha.)),
x=ProsperRating..Alpha., geom="bar")
grid.arrange(q1, q2, ncol=1)
# Chunk 9
ggplot(data=loans, aes(x=AverageCredit)) +
geom_histogram()
# Chunk 10
delinquency_types <- levels(loans$LoanStatus)[c(5, 7:12)]
late_or_defaulted_loans <- filter(loans, LoanStatus %in% delinquency_types)
ggplot(data=late_or_defaulted_loans, aes(x=AverageCredit)) +
geom_density(color="red") +
xlim(300, 850)
# Chunk 11
ggplot(data=loans, aes(x=LoanStatus)) +
geom_bar() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# Chunk 12: DebtIncomeRatio
ggplot(data=loans, aes(x=DebtToIncomeRatio)) +
geom_histogram(binwidth=.01)
# Chunk 13
summary(loans[which(loans$DebtToIncomeRatio==10.01),]
[,c("ProsperScore",
"ProsperRating..Alpha.",
"IncomeRange",
"StatedMonthlyIncome",
"DebtToIncomeRatio",
"MonthlyLoanPayment",
"LoanOriginalAmount")])
# Chunk 14
nrow(loans[which(loans$DebtToIncomeRatio>=10.01),])
# Chunk 15
sort(table(subset(loans, DebtToIncomeRatio>10)$IncomeRange),decreasing = T)
# Chunk 16
ggplot(data=loans, aes(x=DebtToIncomeRatio)) +
geom_histogram(binwidth=.01) +
coord_cartesian(xlim=c(0.1, 1.0))
# Chunk 17
ggplot(data=loans, aes(x=IncomeRange)) +
geom_bar() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# Chunk 18
ggplot(data=loans) +
geom_histogram(aes(x=BorrowerRate), binwidth=.01) +
xlim(c(0.0, 0.4))
# Chunk 19
poor_saps <- subset(loans, BorrowerRate >= 0.31 & BorrowerRate <=0.32)
summary(poor_saps[c("ProsperRating..Alpha.",
"StatedMonthlyIncome",
"BorrowerRate",
"LenderYield",
"AverageCredit")])
# Chunk 20
ggplot(data=loans) +
geom_histogram(aes(x=StatedMonthlyIncome), binwidth=1000) +
xlim(c(0, 35000))
# Chunk 21
valid_statuses <- c("Completed", "Current", "Chargedoff", "Defaulted")
loans_with_status <- subset(loans, LoanStatus %in% valid_statuses)
ggplot(data=loans_with_status,
aes(x = LoanStatus, y = DebtToIncomeRatio))+
geom_boxplot() +
scale_y_continuous(limits = c(0.0, 1.5))
# Chunk 22
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.))) +
geom_histogram(aes(x=ProsperScore), stat="count") +
facet_wrap(~ ProsperRating..Alpha.)
# Chunk 23
table(ProsperScore, ProsperRating..Alpha.)
# Chunk 24: Boxplot
ggplot(aes(x=ProsperRating..Alpha., y=AverageCredit),
data = subset(loans, !is.na(ProsperRating..Alpha.))) +
geom_boxplot(na.rm = T) + ylim(c(600,900)) +
geom_hline(yintercept = mean(loans$AverageCredit, na.rm = T))
# Chunk 25
status_types <- levels(loans$LoanStatus)[c(2:5)]
loans_with_status <- filter(loans, LoanStatus %in% status_types)
ggplot(data=loans_with_status, aes(x=LoanStatus, y=AverageCredit)) +
geom_boxplot() +
ylim(400, 850)
# Chunk 26
ggplot(data=loans_with_status, aes(x=ProsperRating..Alpha., fill=LoanStatus)) +
geom_bar(position = "dodge") +
scale_color_brewer(type="qual")
# Chunk 27: CorrelationGrid
loans_samp <- loans[sample(1:length(loans$AverageCredit), 5000), ]
loans_samp <- loans_samp[, c(1,4:5, 8:9, 10:12, 15)]
ggcorr(loans_samp, name = "Pearson's CorrCoeff")
# Chunk 28: Interest Types over Rating
loans$BorrowerRate.bucket = cut(loans$BorrowerRate,
c(0. , 0.15, 0.2, 0.28, 5.1))
ggplot(aes(x = BorrowerRate.bucket,
y = BorrowerAPR ,
fill = ProsperRating..Alpha.),
data = subset(loans, !is.na(ProsperRating..Alpha.)) ) +
geom_boxplot( )
# Chunk 29
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x=BorrowerRate, y=BorrowerAPR)) +
geom_point(alpha=1/50, color = "red") +
facet_wrap(~ProsperRating..Alpha.)
# Chunk 30
ggplot(aes(x = IncomeRange,
y = LoanOriginalAmount),
data=subset(loans, (StatedMonthlyIncome < 11000))) +
geom_boxplot(aes(fill = LoanStatus) )   +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# Chunk 31
p1 <-  ggplot(data=subset(loans, StatedMonthlyIncome > 0),
aes(x = AverageCredit, y=StatedMonthlyIncome)) +
geom_smooth(method="lm", aes(color=IsBorrowerHomeowner)) + xlim(300, 850)
p2 <- ggplot(data=loans, aes(x=AverageCredit, y=LoanOriginalAmount)) +
geom_smooth(method="lm", aes(color=IsBorrowerHomeowner)) + xlim(300, 850)
grid.arrange(p1,p2, ncol = 1)
lm(AverageCredit ~ BorrowerRate,
data=subset(loans, IsBorrowerHomeowner == "True"))
lm(AverageCredit ~ BorrowerRate,
data=subset(loans, IsBorrowerHomeowner == "False"))
# Chunk 32
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x = MonthlyLoanPayment, y = DebtToIncomeRatio,
color = ProsperRating..Alpha.)) +
geom_point(alpha = 0.5, size = 1) +
scale_x_continuous(limits=c(0, 1500)) +
scale_y_continuous(limits = c(0.0, 1.5))
# Chunk 33
grouped_status <- loans_with_status %>%
group_by(ProsperRating..Alpha., LoanStatus) %>%
summarize(Counts = n()) %>%
group_by(ProsperRating..Alpha.) %>%
mutate(Relative.Freq = Counts/sum(Counts)) %>%
arrange(ProsperRating..Alpha.)
ggplot(data=grouped_status, aes(x=ProsperRating..Alpha.,
y=Relative.Freq,
fill=LoanStatus)) +
geom_bar(stat = "identity", position = "dodge") +
scale_color_brewer(type="seq") +
ggtitle("Relative Frequencies of Loans by Prosper Rating and Loan Status") +
xlab("Prosper Rating Category") +
ylab("Frequency, Relative to Total Loans in a Rating Category")
#dplyr help courtesy of this SO thread, which is itself courtesy of mentor Myles
#on the Udacity discussion forum:
#https://stackoverflow.com/questions/24576515/relative-frequencies-proportions-with-dplyr
# Chunk 34
ggplot(subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x=ProsperRating..Alpha., y=AverageCredit,
fill=ProsperRating..Alpha.)) +
ggtitle("Average Credit Boxplot by Prosper Rating") +
geom_boxplot(alpha=0.7) +
theme(legend.position = 'none') +
geom_hline(yintercept = mean(loans$AverageCredit, na.rm = T),
col="red") +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=5,
color="blue",
fill="red") +
scale_fill_brewer(palette="Set3") +
ylim(600, 850) +
xlab("ProsperRating") +
ylab("Average Credit Scores")
#adapted from http://www.r-graph-gallery.com/269-ggplot2-boxplot-with-average-value/
# Chunk 35
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x = MonthlyLoanPayment, y = DebtToIncomeRatio,
color = ProsperRating..Alpha.)) +
ggtitle("Debt to Income Ratio Versus Stated Monthly Income") +
geom_point(alpha = 0.8, size = 1) +
stat_ellipse(size=2) +
scale_x_continuous(limits=c(0, 1500)) +
scale_y_continuous(limits = c(0.0, 1.5)) +
xlab(label = "Monthly Loan Payments in USD") +
ylab(label = "Ratio of Debt to Borrower Income") +
scale_color_brewer(type='seq', palette = "PuBuGn",
guide=guide_legend(title='ProsperRating'))
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
data.frame(round(na_count/nrow(loans), 4))
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_counts <- data.frame(round(na_count/nrow(loans), 4))
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[2] <- "Percent of Empty Values in Data Set"
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[1] <- "Percent of Empty Values in Data Set"
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[1] <- "Percent of Empty Values in Data Set"
na_counts
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[1] <- "Percent of Empty Values in Data Set"
print(na_counts)
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[1] <- "Percent of Empty Values in Data Set"
na_counts
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[1] <- "Percent Missing a Value"
na_counts
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
na_count <-sapply(loans, function(y) sum(length(which(is.na(y)))))
na_counts <- data.frame(round(na_count/nrow(loans), 4))
names(na_counts)[1] <- "Percent of Loans Missing Value"
na_counts
#NA counting lambda code courtesty of Stack Overflow:
# https://stackoverflow.com/questions/24027605/
# determine-the-number-of-na-values-in-a-column
loans[loans$ProsperScore==1]
loans[loans$ProsperScore==1,]
loans[loans$ProsperScore==1,]$LoanStatus
?split
summary(loans[which(loans$DebtToIncomeRatio==10.01),])
summary(loans[which(loans$DebtToIncomeRatio==10.01),]
[,c("ProsperScore",
"AverageCredit",
"ProsperRating..Alpha.",
"IncomeRange",
"StatedMonthlyIncome",
"DebtToIncomeRatio",
"MonthlyLoanPayment",
"LoanOriginalAmount")])
sort(table(subset(loans, DebtToIncomeRatio>10)$IncomeRange),decreasing = T)
ggplot(data=loans, aes(x=DebtToIncomeRatio)) +
geom_histogram(binwidth=.01)
ggplot(data=loans, aes(x=DebtToIncomeRatio)) +
geom_histogram(binwidth=.01) +
coord_cartesian(xlim=c(0.1, 1.0))
ggplot(data=loans, aes(x=IncomeRange)) +
geom_bar() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplot(data=loans) +
geom_histogram(aes(x=BorrowerRate), binwidth=.01) +
xlim(c(0.0, 0.4))
poor_saps <- subset(loans, BorrowerRate >= 0.31 & BorrowerRate <=0.32)
summary(poor_saps[c("ProsperRating..Alpha.",
"StatedMonthlyIncome",
"BorrowerRate",
"LenderYield",
"AverageCredit")])
ggplot(data=loans) +
geom_histogram(aes(x=StatedMonthlyIncome), binwidth=1000) +
xlim(c(0, 35000))
valid_statuses <- c("Completed", "Current", "Chargedoff", "Defaulted")
loans_with_status <- subset(loans, LoanStatus %in% valid_statuses)
ggplot(data=loans_with_status,
aes(x = LoanStatus, y = DebtToIncomeRatio))+
geom_boxplot() +
scale_y_continuous(limits = c(0.0, 1.5))
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.))) +
geom_histogram(aes(x=ProsperScore), stat="count") +
facet_wrap(~ ProsperRating..Alpha.)
ggplot(aes(x=ProsperRating..Alpha., y=AverageCredit),
data = subset(loans, !is.na(ProsperRating..Alpha.))) +
geom_boxplot(na.rm = T) + ylim(c(600,900)) +
geom_hline(yintercept = mean(loans$AverageCredit, na.rm = T))
status_types <- levels(loans$LoanStatus)[c(2:5)]
loans_with_status <- filter(loans, LoanStatus %in% status_types)
ggplot(data=loans_with_status, aes(x=LoanStatus, y=AverageCredit)) +
geom_boxplot() +
ylim(400, 850)
ggplot(data=loans_with_status, aes(x=ProsperRating..Alpha., fill=LoanStatus)) +
geom_bar(position = "dodge") +
scale_color_brewer(type="qual")
loans$BorrowerRate.bucket = cut(loans$BorrowerRate,
c(0. , 0.15, 0.2, 0.28, 5.1))
ggplot(aes(x = BorrowerRate.bucket,
y = BorrowerAPR ,
fill = ProsperRating..Alpha.),
data = subset(loans, !is.na(ProsperRating..Alpha.)) ) +
geom_boxplot( )
p1 <-  ggplot(data=subset(loans, StatedMonthlyIncome > 0),
aes(x = AverageCredit, y=StatedMonthlyIncome)) +
geom_smooth(method="lm", aes(color=IsBorrowerHomeowner)) + xlim(300, 850)
p2 <- ggplot(data=loans, aes(x=AverageCredit, y=LoanOriginalAmount)) +
geom_smooth(method="lm", aes(color=IsBorrowerHomeowner)) + xlim(300, 850)
grid.arrange(p1,p2, ncol = 1)
lm(AverageCredit ~ BorrowerRate,
data=subset(loans, IsBorrowerHomeowner == "True"))
lm(AverageCredit ~ BorrowerRate,
data=subset(loans, IsBorrowerHomeowner == "False"))
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x = MonthlyLoanPayment, y = DebtToIncomeRatio,
color = ProsperRating..Alpha.)) +
geom_point(alpha = 0.5, size = 1) +
scale_x_continuous(limits=c(0, 1500)) +
scale_y_continuous(limits = c(0.0, 1.5))
grouped_status <- loans_with_status %>%
group_by(ProsperRating..Alpha., LoanStatus) %>%
summarize(Counts = n()) %>%
group_by(ProsperRating..Alpha.) %>%
mutate(Relative.Freq = Counts/sum(Counts)) %>%
arrange(ProsperRating..Alpha.)
ggplot(data=grouped_status, aes(x=ProsperRating..Alpha.,
y=Relative.Freq,
fill=LoanStatus)) +
geom_bar(stat = "identity", position = "dodge") +
scale_color_brewer(type="seq") +
ggtitle("Relative Frequencies of Loans by Prosper Rating and Loan Status") +
xlab("Prosper Rating Category") +
ylab("Frequency, Relative to Total Loans in a Rating Category")
#dplyr help courtesy of this SO thread, which is itself courtesy of mentor Myles
#on the Udacity discussion forum:
#https://stackoverflow.com/questions/24576515/relative-frequencies-proportions-with-dplyr
ggplot(subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x=ProsperRating..Alpha., y=AverageCredit,
fill=ProsperRating..Alpha.)) +
ggtitle("Average Credit Boxplot by Prosper Rating") +
geom_boxplot(alpha=0.7) +
theme(legend.position = 'none') +
geom_hline(yintercept = mean(loans$AverageCredit, na.rm = T),
col="red") +
stat_summary(fun.y=mean,
geom="point",
shape=20,
size=5,
color="blue",
fill="red") +
scale_fill_brewer(palette="Set3") +
ylim(600, 850) +
xlab("ProsperRating") +
ylab("Average Credit Scores")
#adapted from http://www.r-graph-gallery.com/269-ggplot2-boxplot-with-average-value/
ggplot(data=subset(loans, !is.na(ProsperRating..Alpha.)),
aes(x = MonthlyLoanPayment, y = DebtToIncomeRatio,
color = ProsperRating..Alpha.)) +
ggtitle("Debt to Income Ratio Versus Stated Monthly Income") +
geom_point(alpha = 0.8, size = 1) +
stat_ellipse(size=2) +
scale_x_continuous(limits=c(0, 1500)) +
scale_y_continuous(limits = c(0.0, 1.5)) +
xlab(label = "Monthly Loan Payments in USD") +
ylab(label = "Ratio of Debt to Borrower Income") +
scale_color_brewer(type='seq', palette = "PuBuGn",
guide=guide_legend(title='ProsperRating'))
